<h1>Getting Started on Heroku with PHP</h1>
<h3>Set up</h3>
Before you continue, check that you have the prerequisites installed properly. Type each command below and make sure it displays the version you have installed. (Your versions might be different from the example.) If no version is returned, go back to the introduction of this tutorial and install the prerequisites.

All of the following local setup will be required to complete the “Declare app dependencies” and subsequent steps.

<img src=tgs/Screenshot_2.png>

<h3>Prepare the app</h3>
To clone the sample application so that you have a local version of the code that you can then deploy to Heroku, execute the following commands in your local command shell or terminal:

<img src=tgs/Screenshot_3.png>
You now have a functioning git repository that contains a simple application as well as a composer.json file. Make sure you’ve installed Composer. Heroku uses Composer for dependency management in PHP projects, and the composer.json file indicates to Heroku that your application is written in PHP.

<h3>Deploy the app</h3>
In this step you will deploy the app to Heroku.

Create an app on Heroku, which prepares Heroku to receive your source code:
<img src=tgs/Screenshot_4.png>
When you create an app, a git remote (called heroku) is also created and associated with your local git repository.

Now deploy your code:

<img src=tgs/Screenshot_5.png>

The application is now deployed. Ensure that at least one instance of the app is running:

<img src=tgs/Screenshot_6.png>

The application is now deployed. Ensure that at least one instance of the app is running:

<img src=tgs/Screenshot_7.png>

Now visit the app at the URL generated by its app name.

<img src=tgs/Screenshot_8.png>

<h3>View logs</h3>
View information about your running app using one of the logging commands, heroku logs --tail:

<img src=tgs/Screenshot_7b.png>

<h3>Define a Procfile</h3>
The Procfile in the example app you deployed looks like this:
<img src=tgs/Screenshot_9.png>

<h3>Scale the app</h3>
You can check how many dynos are running using the ps command:
<img src=tgs/Screenshot_10.png>
<br>
Scaling an application on Heroku is equivalent to changing the number of dynos that are running. Scale the number of web dynos to zero:
<img src=tgs/Screenshot_11.png>
<img src=tgs/Screenshot_12.png>
<br>
Access the app again by hitting refresh on the web tab, or heroku open to open it in a web tab. You will get an error message because you no longer have any web dynos available to serve requests.

Scale it up again:
<br>
<img src=tgs/Screenshot_13.png>
<img src=tgs/Screenshot_14.png>
<br>

<h3>Declare app dependencies</h3>
Heroku recognizes an app as PHP by the existence of a composer.json file in the root directory.

The demo app you deployed already has a composer.json, and it looks something like this:
<img src=tgs/Screenshot_15.png>
<br>
Run the following command to install the dependencies, preparing your system for running the app locally:

<img src=tgs/Screenshot_16.png>
<img src=tgs/Screenshot_17.png>
<br>

<h3>Push local changes</h3>
In this step you’ll learn how to propagate a local change to the application through to Heroku. As an example, you’ll modify the application to add an additional dependency (the Cowsay library) and the code to use it.

First, use composer to require the new dependency:
<img src=tgs/Screenshot_18.png>
<br>
This will also change composer.json. If you introduced the dependency by modifying the composer.json file yourself, be sure to update the dependencies by running:
<img src=tgs/Screenshot_19.png>

Now modify web/index.php to use this library. Add a new route after the existing one, for /cowsay:

<img src=tgs/Screenshot_20.png>

When that route is visited, it will render a beautiful cow.

Now deploy. Almost every deploy to Heroku follows this same pattern.

First, add the modified files to the local git repository:

<img src=tgs/Screenshot_21a.png>

Now commit the changes to the repository:

<img src=tgs/Screenshot_21b.png>

Now deploy, just as you did previously:

<img src=tgs/Screenshot_21c.png>

Finally, check that everything is working:
<br>
<img src=tgs/Screenshot_23.png>
<img src=tgs/Screenshot_22.png>

<h3>Start an interactive shell</h3>
You can run a command, typically scripts and applications that are part of your app, in a one-off dyno using the heroku run command. It can also be used to launch an interactive PHP shell attached to your local terminal for experimenting in your app’s environment:
<img src=tgs/Screenshot_23b.png>
To get a real feel for how dynos work, you can create another one-off dyno and run the bash command, which opens up a shell on that dyno. You can then execute commands there. Each dyno has its own ephemeral filespace, populated with your app and its dependencies - once the command completes (in this case, bash), the dyno is removed.
<img src=tgs/Screenshot_24.png>

<h3>Define config vars</h3>
Heroku lets you externalise configuration - storing data such as encryption keys or external resource addresses in config vars.

At runtime, config vars are exposed as environment variables to the application.

Modify web/index.php so that root route returns the word Hello repeated by the value of the TIMES environment variable:
<br>
<img src=tgs/Screenshot_24b.png>
<br>
To set the config var on Heroku, execute the following :
<br>
<img src=tgs/Screenshot_25b.png>
<br>
View the config vars that are set using heroku config:
<br>
<img src=tgs/Screenshot_25.png>

<h3>Provision a database</h3>
The add-on marketplace has a large number of data stores, from Redis and MongoDB providers, to Postgres and MySQL. In this step you will add a free Heroku Postgres Starter Tier dev database to your app.

Add the database:
<br>
<img src=tgs/Screenshot_26.png>
<br>
This creates a database, and sets a DATABASE_URL config var (you can check by running heroku config).

Modify composer.json to include a dependency for a simple PDO service provider, csanquer/pdo-service-provider:
<img src=tgs/Screenshot_27.png>
<br>
Install the new dependency:
<br>
<img src=tgs/Screenshot_28.png>
<br>
Now modify index.php to extend the app to add a PDO connection:
<br>
<img src=tgs/Screenshot_29b.png>

Note how this code retrieves the DATABASE_URL config var from the environment using getenv(), and extracts information on hostname, database and credentials from that config var using parse_url().

In the same file, add a new handler to query the database:
<br>
<img src=tgs/Screenshot_29v.png>
<br>
This ensures that when you access your app using the /db route, it will return all rows in the test_table table, and render the results using the database.twig template. Create the template in the web/views directory:
<br>
<img src=tgs/Screenshot_29.png>
<br>
If you get lost making these changes, take a look at the db branch of the sample app.

Deploy the app modifications to Heroku:
<br>
<img src=tgs/Screenshot_30.png>
<br>
If you now access /db you will see Nameless in the output as there is no table in the database. Assuming that you have Postgres installed locally, use the heroku pg:psql command to connect to the database you provisioned earlier, create a table and insert a row:
<br>
<img src=tgs/Screenshot_31.png>
<br>
Now when you access your app’s /db route, you will see something like this:
<br>
<img src=tgs/Screenshot_32.png>